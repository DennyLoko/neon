name: "Build Neon"
description: "Build Neon"
inputs:
  build_type:
    required: true
    type: string
  rust_toolchain:
    required: true
    type: string
  install_rust_toolchain:
    required: false
    type: boolean
  upload:
    required: true
    type: boolean

#FIXME
#outputs:
#  binaries:
#    description: "tarball containing the binaries"
#    value: ${{ jobs.my_job.outputs.job_output1 }}

runs:
  using: "composite"
  steps:
    # Set some environment variables used by all the steps.
    #
    # CARGO_FLAGS is extra options to pass to "cargo build", "cargo test" etc.
    #   It also includes --features, if any
    #
    # CARGO_FEATURES is passed to "cargo metadata". It is separate from CARGO_FLAGS,
    #   because "cargo metadata" doesn't accept --release or --debug options
    #
    - name: Set env variables
      run: |
        if [[ $BUILD_TYPE == "debug" ]]; then
          cov_prefix="scripts/coverage --profraw-prefix=$GITHUB_JOB --dir=/tmp/coverage run"
          CARGO_FEATURES=""
          CARGO_FLAGS="--locked"
        elif [[ $BUILD_TYPE == "release" ]]; then
          cov_prefix=""
          CARGO_FEATURES="--features profiling"
          CARGO_FLAGS="--locked --release $CARGO_FEATURES"
        fi
        echo "cov_prefix=${cov_prefix}" >> $GITHUB_ENV
        echo "CARGO_FEATURES=${CARGO_FEATURES}" >> $GITHUB_ENV
        echo "CARGO_FLAGS=${CARGO_FLAGS}" >> $GITHUB_ENV
        echo "COPT=-Werror" >> $GITHUB_ENV
      shell: bash -euxo pipefail {0}
      env:
        BUILD_TYPE: ${{ inputs.build_type }}

    - name: Set platform-specific env
      if: runner.os == 'Linux'
      run: |
        echo 'MAKEFLAGS=-j'`nproc` >> $GITHUB_ENV
        echo 'mold_run=mold -run' >> $GITHUB_ENV
      shell: bash -euxo pipefail {0}

    - name: Install rust toolchain ${{ inputs.rust_toolchain }}
      if: inputs.install_rust_toolchain == 'true'
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: ${{ inputs.rust_toolchain }}
        components: rustfmt, clippy
        override: true

    - name: Install macOS postgres dependencies
      if: runner.os == 'macOS'
      run: |
        brew install flex bison openssl
        echo 'ldflags=-l/usr/local/opt/openssl@3/lib' >> $GITHUB_ENV
        echo 'cppflags=-i/usr/local/opt/openssl@3/include' >> $GITHUB_ENV
        echo 'mold_run=' >> $GITHUB_ENV
      shell: bash -euxo pipefail {0}

    - name: Set pg 14 revision for caching
      id: pg_v14_rev
      run: echo ::set-output name=pg_rev::$(git rev-parse head:vendor/postgres-v14)
      shell: bash -euxo pipefail {0}

    - name: Set pg 15 revision for caching
      id: pg_v15_rev
      run: echo ::set-output name=pg_rev::$(git rev-parse head:vendor/postgres-v15)
      shell: bash -euxo pipefail {0}

    # Don't include the ~/.cargo/registry/src directory. It contains just
    # uncompressed versions of the crates in ~/.cargo/registry/cache
    # directory, and it's faster to let 'cargo' to rebuild it from the
    # compressed crates.
    - name: Cache cargo deps
      id: cache_cargo
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry/
          !~/.cargo/registry/src
          ~/.cargo/git/
          target/
        # Fall back to older versions of the key, if no cache for current Cargo.lock was found
        key: |
          v7-${{ runner.os }}-${{ inputs.build_type }}-cargo-${{ inputs.rust_toolchain }}-${{ hashfiles('cargo.lock') }}
          v7-${{ runner.os }}-${{ inputs.build_type }}-cargo-${{ inputs.rust_toolchain }}-

    - name: Cache postgres v14 build
      id: cache_pg_14
      uses: actions/cache@v3
      with:
        path: pg_install/v14
        key: v1-${{ runner.os }}-${{ inputs.build_type }}-pg-${{ steps.pg_v14_rev.outputs.pg_rev }}-${{ hashFiles('Makefile') }}

    - name: Cache postgres v15 build
      id: cache_pg_15
      uses: actions/cache@v3
      with:
        path: pg_install/v15
        key: v1-${{ runner.os }}-${{ inputs.build_type }}-pg-${{ steps.pg_v15_rev.outputs.pg_rev }}-${{ hashFiles('Makefile') }}

    - name: Build postgres v14
      if: steps.cache_pg_14.outputs.cache-hit != 'true'
      run: ${mold_run} make postgres-v14
      shell: bash -euxo pipefail {0}

    - name: Build postgres v15
      if: steps.cache_pg_15.outputs.cache-hit != 'true'
      run: ${mold_run} make postgres-v15
      shell: bash -euxo pipefail {0}

    - name: Build neon extensions
      run: ${mold_run} make neon-pg-ext
      shell: bash -euxo pipefail {0}

    - name: Check formatting of Rust code
      if: inputs.build_type == 'debug'
      run: cargo fmt --all -- --check
      shell: bash -euxo pipefail {0}

    - name: Run cargo build
      run: |
        # Print the versions used into the build log
        cargo --version
        rustc --version
        ${cov_prefix} ${mold_run} cargo build $CARGO_FLAGS --features failpoints --bins --tests
      shell: bash -euxo pipefail {0}

    - name: Run cargo test
      run: |
        ${cov_prefix} cargo test $CARGO_FLAGS
      shell: bash -euxo pipefail {0}

    - name: Run cargo clippy
      if: inputs.build_type == 'debug'
      run: ./run_clippy.sh
      shell: bash -euxo pipefail {0}

    - name: Install rust binaries
      if: inputs.upload
      run: |
        # Install target binaries
        mkdir -p /tmp/neon/bin/
        binaries=$(
          ${cov_prefix} cargo metadata $CARGO_FEATURES --format-version=1 --no-deps |
          jq -r '.packages[].targets[] | select(.kind | index("bin")) | .name'
        )
        for bin in $binaries; do
          SRC=target/$BUILD_TYPE/$bin
          DST=/tmp/neon/bin/$bin
          cp "$SRC" "$DST"
        done

        # Install test executables and write list of all binaries (for code coverage)
        if [[ $BUILD_TYPE == "debug" ]]; then
          # Keep bloated coverage data files away from the rest of the artifact
          mkdir -p /tmp/coverage/

          mkdir -p /tmp/neon/test_bin/

          test_exe_paths=$(
            ${cov_prefix} cargo test $CARGO_FLAGS --message-format=json --no-run |
            jq -r '.executable | select(. != null)'
          )
          for bin in $test_exe_paths; do
            SRC=$bin
            DST=/tmp/neon/test_bin/$(basename $bin)

            # We don't need debug symbols for code coverage, so strip them out to make
            # the artifact smaller.
            strip "$SRC" -o "$DST"
            echo "$DST" >> /tmp/coverage/binaries.list
          done

          for bin in $binaries; do
            echo "/tmp/neon/bin/$bin" >> /tmp/coverage/binaries.list
          done
        fi
      shell: bash -euxo pipefail {0}
      env:
        BUILD_TYPE: ${{ inputs.build_type }}

    - name: Install postgres binaries
      if: inputs.upload
      run: cp -a pg_install /tmp/neon/pg_install
      shell: bash -euxo pipefail {0}

    - name: Upload Neon artifact
      if: inputs.upload
      uses: ./.github/actions/upload
      with:
        name: neon-${{ runner.os }}-${{ inputs.build_type }}-${{ inputs.rust_toolchain }}-artifact
        path: /tmp/neon

    # XXX: keep this after the binaries.list is formed, so the coverage can properly work later
    - name: Merge and upload coverage data
      if: inputs.build_type == 'debug' && inputs.upload
      uses: ./.github/actions/save-coverage-data
